[gd_resource type="ShaderMaterial" load_steps=2 format=3 uid="uid://p7x1je6dtmo4"]

[sub_resource type="Shader" id="Shader_gcq0q"]
code = "//ATTENTION:
//  THIS IS SHADE AUTOGENERATED BY
//  THE ADDON SPRITE-SHADER-MIXER
//  ANY MANUAL CHANGES WILL BE REMOVED WHEN THE ADDON
//  UPDATES THIS SHADER.
//  ANYWAY, YOU CAN SAVE THE CURRENT VERSION AS A RESOURCE FILE.
//SHADERS:Squash,LightningX,Color Swap,
shader_type canvas_item;

uniform float opacity:hint_range(0.0, 1.0, 0.01)=1.;

	
/*
Squish Sprite Shader by Garmelon (https://github.com/Garmelon)
Documented by Mateus-Carmo31
*/

uniform bool squash_active = true;
uniform bool uv_mode = false;
uniform float y_factor : hint_range(-1.,3.) = 2.;
uniform float squash : hint_range(-1,3) = 1;


float squash_function(float y)
{
	return sqrt(1.0 - y*y);
}

void squash_func(in vec2 uv, in sampler2D tex, in vec2 size, in vec2 pixelSize, inout vec4 color){

// This will be used to center the laser
    uv =  uv * 2.0 - 1.0;
	uv.y *= 1. / y_factor;
	float displacement = 1.0 + squash * squash_function(uv.y);
	uv.y /= displacement;
	uv = (uv + 1.0) / 2.0;


	
if (uv_mode)
{
    color = uv.y >= 0.0 && uv.y <= 1.0 ? vec4(uv, 0.0, 1.0) : vec4(vec3(0.0), 1.0);
}
else if (uv.y >= 0.0 && uv.y <= 1.0)
{
    color = texture(tex, uv);
}
else
{
    color = vec4(0.0);
}
}


uniform bool LIGHTNINGX_active=true;
uniform float min_offset :hint_range(-1.,1.) = -1.;
uniform float max_offset :hint_range(-1.,1.) = 1.;
uniform int count : hint_range(1, 15) = 1;
uniform vec4 LIGHTNING_lightningColor: source_color=vec4(1,1,1,1);
uniform float LIGHTNING_size: hint_range (0.,.4)=0.01;
uniform float LIGHTNING_width: hint_range (0.,.9)=.05;
uniform float LIGHTNING_speed:hint_range(0.0, 15.0, 0.1)=4;
uniform float LIGHTNING_frequency:hint_range(0.0, 100.0, 0.1)=20.;
uniform float LIGHTNING_flash:hint_range(0.0, 15.0, 0.1)=15.0;
uniform float LIGHTNING_time_shift:hint_range(0.0, 15.0, 0.1)=15;

float LIGHTNING_rand(float x){
	return fract(sin(x)*100000.0);
}

float min_max_sin(float x){
    return float (min_offset +(sin(x) + 1.0) * 0.5 * (max_offset - min_offset));
}

void lightningx(in vec2 uv, in sampler2D sampler,in vec2 texSize, vec2 pixelSize, inout vec4 color){
    const int max_const = 11;
    float bolt[max_const];
    float wave[max_const];
    float blink;
    vec4 display[max_const];
    
        for (int i = 0; i < count; i++ ){
    	    bolt[i] = abs(mod(uv.x * LIGHTNING_frequency + (LIGHTNING_rand(TIME) + LIGHTNING_time_shift) * LIGHTNING_speed * -1., 0.5)-0.25)-0.125;
            bolt[i] *= 4. * LIGHTNING_width;
 	        wave[i] = abs(uv.y - float(i) * .1  + bolt[i] + (min_max_sin(TIME + float(i)) *.9) )  ;     
            wave[i] = 1. - step(LIGHTNING_size * .2, wave[i]);
           	blink = step(LIGHTNING_rand (TIME) * LIGHTNING_flash  , float(i) );
	        wave[i] *= blink;
            
	        display[i] = LIGHTNING_lightningColor * vec4(wave[i]);
	        color =vec4(color.rgb + display[i].rgb , color.a);
        }
        
    }
  

uniform bool  COLORSWAP_active = true;
uniform float COLORSWAP_mix:hint_range(0,1,0.1) = 0;
uniform int   COLORSWAP_max_colors:hint_range(1, 8, 1) = 8;
uniform bool  COLORSWAP_show_stripes = true;
uniform float COLORSWAP_tolerance: hint_range(0.0, 1, 0.1);
uniform vec4  COLORSWAP_input_color1 : source_color;
uniform vec4  COLORSWAP_output_color1 : source_color;
uniform vec4  COLORSWAP_input_color2 : source_color;
uniform vec4  COLORSWAP_output_color2 : source_color;
uniform vec4  COLORSWAP_input_color3 : source_color;
uniform vec4  COLORSWAP_output_color3 : source_color;
uniform vec4  COLORSWAP_input_color4 : source_color;
uniform vec4  COLORSWAP_output_color4 : source_color;
uniform vec4  COLORSWAP_input_color5 : source_color;
uniform vec4  COLORSWAP_output_color5 : source_color;
uniform vec4  COLORSWAP_input_color6 : source_color;
uniform vec4  COLORSWAP_output_color6 : source_color;
uniform vec4  COLORSWAP_input_color7 : source_color;
uniform vec4  COLORSWAP_output_color7 : source_color;
uniform vec4  COLORSWAP_input_color8 : source_color;
uniform vec4  COLORSWAP_output_color8 : source_color;
vec4 COLORSWAP_grayscale(vec4 color){
	float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
	return vec4(gray, gray, gray, color.a);
}
vec4 COLORSWAP_stripe(vec2 uv, vec4 color){
	float w = cos(0.7854) * uv.x + sin(0.7854) * uv.y - 0.05 * TIME;
	if (floor(mod(w * 48.0, 2.0)) < 0.0001) {
		return color;
	}
	else {
		return COLORSWAP_grayscale(color);
	}
}
bool COLORSWAP_isColorSimilar(vec4 color1, vec4 color2){
		return (
			color1.r > (color2.r - COLORSWAP_tolerance) && 
		    color1.r < (color2.r + COLORSWAP_tolerance) && 
			color1.g > (color2.g - COLORSWAP_tolerance) && 
		    color1.g < (color2.g + COLORSWAP_tolerance) &&
			color1.b > (color2.b - COLORSWAP_tolerance) && 
		    color1.b < (color2.b + COLORSWAP_tolerance)
			);
}
void colorswap(in vec2 uv, in sampler2D txt, in vec2 size, in vec2 pixelSize, inout vec4 finalColor){
	vec4[] input_colors = {
		COLORSWAP_input_color1,
		COLORSWAP_input_color2,
		COLORSWAP_input_color3,
		COLORSWAP_input_color4,
		COLORSWAP_input_color5,
		COLORSWAP_input_color6,
		COLORSWAP_input_color7,
		COLORSWAP_input_color8
	};
	
	vec4[] output_colors = {
		COLORSWAP_output_color1,
		COLORSWAP_output_color2,
		COLORSWAP_output_color3,
		COLORSWAP_output_color4,
		COLORSWAP_output_color5,
		COLORSWAP_output_color6,
		COLORSWAP_output_color7,
		COLORSWAP_output_color8
	};
		
	bool is_color = false;
	
	for(int cr = 0; cr < COLORSWAP_max_colors; cr++){
		if (finalColor.a>0. && COLORSWAP_isColorSimilar(finalColor, input_colors[cr])){
			finalColor = mix(output_colors[cr], finalColor, COLORSWAP_mix);
			is_color = true;
			break;
		}
	}

	if (!is_color){
		if (COLORSWAP_show_stripes && !(finalColor.a < 0.001)){
			finalColor = mix(COLORSWAP_stripe(uv, finalColor), finalColor, COLORSWAP_mix);
		}
	}
}


void fragment() {
	vec4 color = texture(TEXTURE, UV);
	vec2 size = vec2(textureSize(TEXTURE, 0));
	vec2 uv = UV;
	vec2 screen_uv = SCREEN_UV;

	if(squash_active) squash_func(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);
	if(LIGHTNINGX_active) lightningx(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);
	if(COLORSWAP_active) colorswap(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);


	color.a*=opacity;
	COLOR=color;
}

void vertex() {
	
}
"

[resource]
shader = SubResource("Shader_gcq0q")
shader_parameter/opacity = 0.77
shader_parameter/squash_active = true
shader_parameter/uv_mode = false
shader_parameter/y_factor = 2.0
shader_parameter/squash = 1.0
shader_parameter/LIGHTNINGX_active = true
shader_parameter/min_offset = -1.0
shader_parameter/max_offset = 2.0
shader_parameter/count = 15
shader_parameter/LIGHTNING_lightningColor = Color(0.526776, 0.998951, 1, 1)
shader_parameter/LIGHTNING_size = 0.6
shader_parameter/LIGHTNING_width = 0.665
shader_parameter/LIGHTNING_speed = 15.0
shader_parameter/LIGHTNING_frequency = 56.3
shader_parameter/LIGHTNING_flash = 0.0
shader_parameter/LIGHTNING_time_shift = 0.0
shader_parameter/COLORSWAP_active = true
shader_parameter/COLORSWAP_mix = 0.0
shader_parameter/COLORSWAP_max_colors = 8
shader_parameter/COLORSWAP_show_stripes = false
shader_parameter/COLORSWAP_tolerance = 0.6
shader_parameter/COLORSWAP_input_color1 = Color(0.721569, 0.94902, 0.94902, 1)
shader_parameter/COLORSWAP_output_color1 = Color(0.94902, 0.94902, 0.94902, 1)
shader_parameter/COLORSWAP_input_color2 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_output_color2 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_input_color3 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_output_color3 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_input_color4 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_output_color4 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_input_color5 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_output_color5 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_input_color6 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_output_color6 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_input_color7 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_output_color7 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_input_color8 = Color(0, 0, 0, 1)
shader_parameter/COLORSWAP_output_color8 = Color(0, 0, 0, 1)
