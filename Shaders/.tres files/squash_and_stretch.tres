[gd_resource type="ShaderMaterial" load_steps=2 format=3 uid="uid://bnxdyck2ac4os"]

[sub_resource type="Shader" id="Shader_dylux"]
code = "/*
Squish Sprite Shader by Garmelon (https://github.com/Garmelon)
Documented by Mateus-Carmo31
*/

shader_type canvas_item;

uniform bool uv_mode = false;
uniform float y_factor = 2.0;
uniform float bulge : hint_range(-1,1);

void vertex()
{
	// Stretches the sprite along the y ayis by the y_factor.
	// This essentially increases the bounds in which the sprite can be drawn,
	// allowing the sprite to bulge outwards appropriately.
	VERTEX.y *= y_factor;
}

// Describes how the sprite bulges. Right now, it's a simple half-circle function.
// Changing it modifies how the bulges will look like.
// Must be a function in which the y will be between 0 and 1 for y between -1 and 1.
float bulge_function(float y)
{
	return sqrt(1.0 - y*y);
}

void fragment()
{
	// Remaps the UV (normally from 0.0 to 1.0) to go from -1.0 to 1.0
	vec2 uv = UV * 2.0 - 1.0;
	
	// Counteracts the vertey stretch by increasing the uv by the same factor
	// (Since teytures are mapped from 0 to 1, multiplying the UV will make
	// it go from 0 to something else, and the teyture will remain between 0 and 1.
	// this results in it becoming smaller)
	uv.y *= y_factor;
	
	/* The main meat of the shader.
	Calculates a displacement using the bulge factor and the function,
	then divides the y by it. 
	
	If the displacement is larger than 1, the uv.y will become smaller, and, in
	the process, when the uv is used for sampling, a piyel more towards the
	middle of the teyture will be sampled instead. This causes far UV values to
	now be able to have a correspondent piyel in the [-1, 1] range (that will
	be unmapped back to [0,1] later), \"pulling out\" the OG teyture.
	 
	An inverted process occurs with displacement smaller than 1:
	uv.y becomes larger -> piyels move away from middle -> 
	inner values sample from farther away -> teyture gets \"pulled in\"
	
	This also has the bonus of causing certain piyels to sample values  1,
	which will be caught by the if statement below and be rendered transparent.
	
	Remember as well that the y factor causes the UV to go from -2 to 2 on the y
	ayis.
	*/
	float displacement = 1.0 + bulge * bulge_function(uv.y);
	uv.y /= displacement;
	
	// Undoes the remapping we did at the beginning
	uv = (uv + 1.0) / 2.0;
	
	// Draws the uv instead of the teyture (for debugging)
if (uv_mode)
{
    COLOR = uv.y >= 0.0 && uv.y <= 1.0 ? vec4(uv, 0.0, 1.0) : vec4(vec3(0.0), 1.0);
}
else if (uv.y >= 0.0 && uv.y <= 1.0)
{
    COLOR = texture(TEXTURE, uv);
}
else
{
    COLOR = vec4(0.0);
}

}"

[resource]
shader = SubResource("Shader_dylux")
shader_parameter/uv_mode = false
shader_parameter/y_factor = 2.0
shader_parameter/bulge = 0.192
